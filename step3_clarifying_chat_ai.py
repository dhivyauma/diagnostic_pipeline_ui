# step3_clarifying_chat_ai.py
import streamlit as st
from typing import Dict, Any, List, Optional
from datetime import datetime
import json
from pathlib import Path
from pydantic import BaseModel, Field
import os


class DiagnosticContext(BaseModel):
    """Context for the diagnostic pipeline"""
    model_type: str = Field(..., description="Model type (PD, LGD, EAD)")
    portfolio: str = Field(..., description="Portfolio type (Retail, Commercial, Wholesale)")
    purpose: str = Field(..., description="Purpose (IFRS9, AIRB, Adjudication)")
    active_requirements: Dict[str, Any] = Field(..., description="Active requirements from Step 2")
    collected_data: Dict[str, Any] = Field(default_factory=dict, description="Collected user responses so far")


class FieldStatus(BaseModel):
    """Status of a field in the clarifying chat"""
    field_name: str
    status: str = Field(..., description="pending, provided, clarified")
    value: Optional[str] = None
    timestamp: Optional[datetime] = None


class ClarifyingQuestion(BaseModel):
    """A clarifying question generated by the AI agent"""
    field_name: str
    question: str
    context: str
    example: Optional[str] = None
    is_mandatory: bool
    field_type: str


class UserResponse(BaseModel):
    """User response to a clarifying question"""
    field_name: str
    response: str
    timestamp: datetime = Field(default_factory=datetime.now)


class ChatSession(BaseModel):
    """Complete chat session state"""
    context: DiagnosticContext
    collected_data: Dict[str, str] = Field(default_factory=dict)
    field_status: Dict[str, FieldStatus] = Field(default_factory=dict)
    chat_history: List[Dict[str, Any]] = Field(default_factory=list)
    current_question: Optional[ClarifyingQuestion] = None


def _generate_question_text(field_name: str) -> str:
    return f"What is your {field_name.replace('_', ' ')}?"


class ClarifyingChatAIAgent:
    """Step 3 - Clarifying Chat AI Agent
    
    Uses PydanticAI to ask clarifying questions based on the
    diagnostic context and requirements from Step 2.
    """
    
    def __init__(self):
        self.session: Optional[ChatSession] = None
        self.agent = None
        self.last_ai_error: Optional[str] = None
    
    def initialize_session(self, model_type: str, portfolio: str, purpose: str, 
                          active_requirements: Dict[str, Any]) -> None:
        """Initialize a new chat session with the diagnostic context"""
        # Create diagnostic context
        context = DiagnosticContext(
            model_type=model_type,
            portfolio=portfolio,
            purpose=purpose,
            active_requirements=active_requirements
        )
        
        # Initialize session
        self.session = ChatSession(context=context)
        
        # Initialize field status for all requirements
        for field_name in active_requirements.keys():
            self.session.field_status[field_name] = FieldStatus(
                field_name=field_name,
                status="pending"
            )
    
    async def generate_next_question(self) -> Optional[ClarifyingQuestion]:
        """Generate the next clarifying question using deterministic rules."""
        if not self.session:
            raise ValueError("Session not initialized")
        
        # Check if we're done
        next_field = self._get_next_field_to_ask()
        if next_field == "ALL_COMPLETE":
            return None

        field_config = self.session.context.active_requirements.get(next_field, {})

        question = ClarifyingQuestion(
            field_name=next_field,
            question=_generate_question_text(next_field),
            context=str(field_config.get('description', '') or ''),
            example=field_config.get('example'),
            is_mandatory=field_config.get('mandatory', False),
            field_type=self._determine_field_type(field_config),
        )
        self.session.current_question = question
        return question

    def _get_next_field_to_ask(self) -> str:
        """Get the next field to ask about"""
        if not self.session:
            return "ALL_COMPLETE"
        
        collected = set(self.session.collected_data.keys())
        
        # Priority: mandatory fields first
        for field_name, field_config in self.session.context.active_requirements.items():
            if field_config.get('mandatory', False) and field_name not in collected:
                return field_name
        
        # Then optional fields
        for field_name, field_config in self.session.context.active_requirements.items():
            if not field_config.get('mandatory', False) and field_name not in collected:
                return field_name
        
        return "ALL_COMPLETE"

    def _determine_field_type(self, field_config: Dict[str, Any]) -> str:
        """Determine the appropriate input type for the field"""
        example = field_config.get('example', '').lower()
        
        # Check for boolean indicators
        if any(indicator in example for indicator in ['yes/no', 'true/false', 'on/off']):
            return 'boolean'
        
        # Check for numeric indicators
        if any(indicator in example for indicator in ['years', 'months', '%', 'rate']):
            return 'numeric'
        
        return 'text'
    
    def process_user_response(self, field_name: str, user_input: str) -> Dict[str, Any]:
        """Process and validate user response"""
        if not self.session:
            return {'success': False, 'message': 'Session not initialized'}
        
        try:
            # Validate input
            if not user_input or not user_input.strip():
                return {
                    'success': False,
                    'message': 'Response cannot be empty',
                    'field_name': field_name
                }
            
            # Store the response
            cleaned_input = user_input.strip()
            self.session.collected_data[field_name] = cleaned_input
            self.session.context.collected_data[field_name] = cleaned_input
            
            # Update field status
            self.session.field_status[field_name].status = "provided"
            self.session.field_status[field_name].value = cleaned_input
            self.session.field_status[field_name].timestamp = datetime.now()
            
            # Add to chat history
            self.session.chat_history.append({
                'role': 'user',
                'field_name': field_name,
                'content': cleaned_input,
                'timestamp': datetime.now().isoformat()
            })
            
            return {
                'success': True,
                'message': f"{field_name.replace('_', ' ').title()} recorded successfully.",
                'field_name': field_name,
                'value': cleaned_input
            }
            
        except Exception as e:
            return {
                'success': False,
                'message': f"Error processing response: {str(e)}",
                'field_name': field_name
            }
    
    def get_completion_status(self) -> Dict[str, Any]:
        """Get the current completion status of all fields"""
        if not self.session:
            return {'error': 'Session not initialized'}
        
        mandatory_fields = [
            field for field, config in self.session.context.active_requirements.items()
            if config.get('mandatory', False)
        ]
        
        optional_fields = [
            field for field, config in self.session.context.active_requirements.items()
            if not config.get('mandatory', False)
        ]
        
        mandatory_completed = sum(
            1 for field in mandatory_fields
            if self.session.field_status.get(field, FieldStatus(field_name=field, status="pending")).status == "provided"
        )
        
        optional_completed = sum(
            1 for field in optional_fields
            if self.session.field_status.get(field, FieldStatus(field_name=field, status="pending")).status == "provided"
        )
        
        return {
            'mandatory_total': len(mandatory_fields),
            'mandatory_completed': mandatory_completed,
            'optional_total': len(optional_fields),
            'optional_completed': optional_completed,
            'all_mandatory_complete': mandatory_completed == len(mandatory_fields),
            'all_complete': (mandatory_completed == len(mandatory_fields) and
                           optional_completed == len(optional_fields))
        }
    
    def get_collected_data(self) -> Dict[str, Any]:
        """Get all collected data in the format expected for Step 4"""
        if not self.session:
            return {'error': 'Session not initialized'}
        
        return {
            'header': {
                'model_type': self.session.context.model_type,
                'portfolio': self.session.context.portfolio,
                'purpose': self.session.context.purpose
            },
            'user_specs': self.session.collected_data.copy(),
            'completion_status': self.get_completion_status(),
            'chat_history': self.session.chat_history.copy(),
            'timestamp': datetime.now().isoformat()
        }
    
    def get_current_json(self) -> Dict[str, Any]:
        """Get the current JSON state in real-time as user fills the form"""
        if not self.session:
            return {'error': 'Session not initialized'}
        
        current_json = {
            'header': {
                'model_type': self.session.context.model_type,
                'portfolio': self.session.context.portfolio,
                'purpose': self.session.context.purpose
            },
            'user_specs': self.session.collected_data.copy(),
            'metadata': {
                'last_updated': datetime.now().isoformat(),
                'completion_status': self.get_completion_status(),
                'total_fields': len(self.session.context.active_requirements),
                'completed_fields': len(self.session.collected_data)
            }
        }
        
        return current_json
    
    def save_current_json(self, filename: Optional[str] = None) -> str:
        """Save the current JSON state to file"""
        if not self.session:
            raise ValueError("Session not initialized")
        
        current_json = self.get_current_json()
        
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            header = current_json["header"]
            filename = f"current_diagnostic_{header['model_type']}_{header['portfolio']}_{header['purpose']}_{timestamp}.json"

        from pathlib import Path as _Path

        base_dir = _Path(__file__).resolve().parent
        output_dir = base_dir / "outputs"
        output_dir.mkdir(parents=True, exist_ok=True)
        
        filepath = output_dir / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(current_json, f, indent=2)
        
        return str(filepath)
    
    def can_proceed_to_step4(self) -> bool:
        """Check if all mandatory fields are complete"""
        if not self.session:
            return False
        
        status = self.get_completion_status()
        return status.get('all_mandatory_complete', False)
    
    def get_field_summary(self) -> List[Dict[str, Any]]:
        """Get a summary of all fields and their status"""
        if not self.session:
            return []
        
        summary = []
        for field_name, field_config in self.session.context.active_requirements.items():
            field_status = self.session.field_status.get(field_name, FieldStatus(field_name=field_name, status="pending"))
            
            summary.append({
                'field_name': field_name,
                'display_name': field_name.replace('_', ' ').title(),
                'mandatory': field_config.get('mandatory', False),
                'status': field_status.status,
                'value': field_status.value or '',
                'description': field_config.get('description', ''),
                'example': field_config.get('example', '')
            })
        
        return summary
    
    def reset_session(self) -> None:
        """Reset the current session"""
        self.session = None
